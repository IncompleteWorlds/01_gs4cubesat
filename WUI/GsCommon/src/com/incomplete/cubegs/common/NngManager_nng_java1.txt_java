package com.incomplete.cubegs.common;

import java.io.InputStream;
import java.nio.ByteBuffer;

import java.util.Properties;

import org.eclipse.rap.rwt.SingletonUtil;


//import com.fasterxml.jackson.core.JsonProcessingException;
//import com.fasterxml.jackson.databind.ObjectMapper;
//import com.fasterxml.jackson.databind.json.JsonMapper;
//import com.fasterxml.jackson.datatype.jdk8.Jdk8Module;
//import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;

//import io.sisu.nng.*;
//import io.sisu.nng.pipeline.Push0Socket;
//import io.sisu.nng.pubsub.Sub0Socket;





public class NngManager_nng_java1 {
    //    private static ObjectMapper objectMapper = JsonMapper.builder() // or different mapper for other format
    //            .addModule(new Jdk8Module())
    //            .addModule(new JavaTimeModule())
    //            // and possibly other configuration, modules, then:
    //            .build();

//    private Push0Socket  server = null;
//    private Sub0Socket   subscriber = null;

    //    private Pointer<nng_socket_s>   server = Pointer.allocate(nng_socket_s.class);
    //    private Pointer<nng_socket_s>   subscriber = Pointer.allocate(nng_socket_s.class);



    private boolean      connectedFlag = false;
    private boolean      connectedSubFlag = false;

    // Only to be executed within the UISession thread
    static public NngManager_nng_java1 getInstance() {
        return SingletonUtil.getSessionInstance(NngManager_nng_java1.class);
    }

    public void connectSub() throws Exception {
        System.out.println("INFO: Creating SUB socket");

        if (this.connectedSubFlag == true) {
            return;
        }

        Properties properties = new Properties();

        // This is required for Tomcat
        InputStream is = this.getClass().getClassLoader().getResourceAsStream("../resources/nng.properties");
        properties.load( is );

        // This is required for Jetty
        //properties.load( new FileInputStream("resources/zeromq.properties") );

        System.out.println("INFO: Properties loaded");


        // Connect with subscriber
        String tmpURL = properties.getProperty("subscriber.address");
        System.out.println("DEBUG: subscriber.address = " + tmpURL);

        if (tmpURL != null && tmpURL.isEmpty() == false) {
            /*
            // rv = nng_sub0_open(&sock)
            int rc = SubLibrary.nngSub0Open(subscriber);
            if (rc != 0) {
                String errorMessage = "ERROR: Unable to create subscriber socket to address: " + tmpURL;
                System.out.println(errorMessage);

                throw new Exception(errorMessage);
            }

            // rv = nng_setopt(sock, NNG_OPT_SUB_SUBSCRIBE, "", 0)

//            Pointer<Byte>  tmpFilter = Pointer.pointerToBytes(SubLibrary.NNG_OPT_SUB_SUBSCRIBE.getBytes());
//            Pointer<?>  tmpTopic = Pointer.pointerToCString("");
            String tmpSub = SubLibrary.NNG_OPT_SUB_SUBSCRIBE;
            Pointer<Byte>  tmpFilter = Pointer.pointerToCString(tmpSub);
            //Pointer<Byte>  tmpTopic = Pointer.pointerToCString("");
            String tmpTT = "";
            Pointer<Byte>  tmpTopic = Pointer.pointerToCString(tmpTT);

            rc = CoreLibrary.nngSetopt(subscriber.get(), tmpFilter, tmpTopic, 0); 
            if (rc != 0) {
                String errorMessage = "ERROR: Unable to create Subscriber socket to address: " + tmpURL;
                System.out.println(errorMessage);

                throw new Exception(errorMessage);
            }

            // Default timeout
            int timeout = Constants.NNG_DEFAULT_TIMEOUT_MILLISECONDS;

            try {
                timeout = Integer.parseInt(properties.getProperty("subscriber.timeout"));
            } catch (Exception e) {
                // Do nothing
            }

            Pointer<Byte>  tmpRecvTimeout = Pointer.pointerToCString(CoreLibrary.NNG_OPT_RECVTIMEO);
            Pointer<Byte>  tmpSendTimeout = Pointer.pointerToCString(CoreLibrary.NNG_OPT_SENDTIMEO);
            Pointer<?>     tmpTimeout = Pointer.pointerToInt(timeout);

            rc = CoreLibrary.nngSetopt(subscriber.get(), tmpRecvTimeout, tmpTimeout, 0); 
            if (rc != 0) {
                String errorMessage = "ERROR: Unable to set reception timeout";
                System.out.println(errorMessage);

                throw new Exception(errorMessage);
            }
            rc = CoreLibrary.nngSetopt(subscriber.get(), tmpSendTimeout, tmpTimeout, 0); 
            if (rc != 0) {
                String errorMessage = "ERROR: Unable to set sending timeout";
                System.out.println(errorMessage);

                throw new Exception(errorMessage);
            }

            // rv = nng_dial(sock, url, NULL, 0)
            Pointer<Byte>  tmpPointerURL = Pointer.pointerToCString( tmpURL.trim() );

            rc = CoreLibrary.nngDial(subscriber.get(), tmpPointerURL, null, 0);
            if (rc != 0) {
                String errorMessage = "ERROR: Unable to Dial Subscriber socket";
                System.out.println(errorMessage);

                throw new Exception(errorMessage);
            }
             */

//            subscriber = new Sub0Socket();
//            // Default timeout
//            int timeout = Constants.NNG_DEFAULT_TIMEOUT_MILLISECONDS;
//
//            try {
//                timeout = Integer.parseInt(properties.getProperty("subscriber.timeout"));
//            } catch (Exception e) {
//                // Do nothing
//            }
//            subscriber.setSendTimeout( timeout );
//            subscriber.setReceiveTimeout(timeout);
//
//            subscriber.dial(tmpURL.trim());
//            
//            subscriber.subscribe("");

            this.connectedSubFlag = true;
        } else {
            String errorMessage = "ERROR: Unable to create subscriber socket to address: " + tmpURL;
            System.out.println(errorMessage);

            throw new Exception(errorMessage);
        }
    }

    public void connect() throws Exception {
        System.out.println("INFO: Creating sockets");

        if (this.connectedFlag == true) {
            return;
        }

        Properties properties = new Properties();

        // This is required for Tomcat
        InputStream is = this.getClass().getClassLoader().getResourceAsStream("../resources/nng.properties");
        properties.load( is );

        // This is required for Jetty
        //properties.load( new FileInputStream("resources/zeromq.properties") );

        System.out.println("INFO: Properties loaded");


        // Connect with the server
        // Asynchronous calls. User .REQ for synchronous calls
        String tmpURL = properties.getProperty("server.address");
        System.out.println("DEBUG: server.address = " + tmpURL);

        if (tmpURL != null && tmpURL.isEmpty() == false) {
            /*
            // rv = nng_sub0_open(&sock)
            int rc = PipelinePushLibrary.nngPush0Open(server);
            if (rc != 0) {
                String errorMessage = "ERROR: Unable to create Push socket to address: " + tmpURL;
                System.out.println(errorMessage);

                throw new Exception(errorMessage);
            }

            int timeout = Constants.NNG_DEFAULT_TIMEOUT_MILLISECONDS;

            try {
                timeout = Integer.parseInt(properties.getProperty("subscriber.timeout"));
            } catch (Exception e) {
                // Do nothing
            }

            Pointer<Byte>  tmpRecvTimeout = Pointer.pointerToCString(CoreLibrary.NNG_OPT_RECVTIMEO);
            Pointer<Byte>  tmpSendTimeout = Pointer.pointerToCString(CoreLibrary.NNG_OPT_SENDTIMEO);
            Pointer<?>     tmpTimeout = Pointer.pointerToInt(timeout);

            rc = CoreLibrary.nngSetopt(server.get(), tmpRecvTimeout, tmpTimeout, 0); 
            if (rc != 0) {
                String errorMessage = "ERROR: Unable to set reception timeout - Push";
                System.out.println(errorMessage);

                throw new Exception(errorMessage);
            }
            rc = CoreLibrary.nngSetopt(server.get(), tmpSendTimeout, tmpTimeout, 0); 
            if (rc != 0) {
                String errorMessage = "ERROR: Unable to set sending timeout - Push";
                System.out.println(errorMessage);

                throw new Exception(errorMessage);
            }

            Pointer<Byte>  tmpPointerURL = Pointer.pointerToCString( tmpURL.trim() );

            rc = CoreLibrary.nngDial(server.get(), tmpPointerURL, null, 0);
            if (rc != 0) {
                String errorMessage = "ERROR: Unable to Dial Push socket";
                System.out.println(errorMessage);

                throw new Exception(errorMessage);
            }
             */

//            server = new Push0Socket();
//
//            // Default timeout
//            int timeout = Constants.NNG_DEFAULT_TIMEOUT_MILLISECONDS;
//
//            try {
//                timeout = Integer.parseInt(properties.getProperty("server.timeout"));
//            } catch (Exception e) {
//                // Do nothing
//            }
//            server.setSendTimeout( timeout );
//            server.setReceiveTimeout(timeout);
//            server.dial(tmpURL.trim());

            this.connectedFlag = true;
        } else {
            String errorMessage = "ERROR: Unable to create server socket to address: " + tmpURL;
            System.out.println(errorMessage);

            throw new Exception(errorMessage);
        }
    }

    // TODO. Call this method when the system is shutdown.
    // I do not think at logout time is required
    public void disconnectSub() {
        if (this.connectedSubFlag == true) {
//            if (subscriber != null) {
//                try {
//                    subscriber.close();
//                } catch (NngException e) {
//                }
//                //                CoreLibrary.nngClose(subscriber.get());
//            }    

            this.connectedSubFlag = false;
        }
    }

    public void disconnect() {
        if (this.connectedFlag == true) {
//            if (server != null) {
//                try {
//                    server.close();
//                } catch (NngException e) {
//                }
//                //                CoreLibrary.nngClose(server.get());
//            }

            this.connectedFlag = false;
        }
    }


    /**
     * Send a message of type T1 and return a message of type T2 or null
     */
    //public <T1, T2> 
    //T2 send(T1 inMessage, Class<T2> classz) throws Exception {
    //    public <T1>
    //    void send(T1 inMessage) throws Exception {
    //        // Connect, if not connected
    //        if (this.connectedFlag == false) {
    //            try {
    //                connect();
    //            } catch(Exception e) {
    //                e.printStackTrace();
    //                
    //                throw e;
    //            }
    //        }
    //        
    //        if ((inMessage instanceof ServerMessage) == false) {
    //            String errorMessage = "Invalid Input Message class type";
    //
    //            System.out.println(errorMessage);
    //
    //            throw new Exception(errorMessage);
    //        }
    //        
    //        String jsonPayload = ((BaseMessage) inMessage).encodeMessage(inMessage);
    //        Message tmpMsg = new Message();
    //        
    //        tmpMsg.append(jsonPayload);
    //        
    //        // Send and wait
    //        server.sendMessage(tmpMsg);
    //        System.out.println("DEBUG Message sent: " + jsonPayload);
    //    }

    public void send(String inMsg) throws Exception {
        // Connect, if not connected
        if (this.connectedFlag == false) {
            try {
                connect();
            } catch(Exception e) {
                e.printStackTrace();

                throw e;
            }
        }

        if (inMsg.isBlank() == false) {            
//            Message tmpMsg = new Message();
//
//            tmpMsg.append(inMsg);
//
//            server.sendMessage(tmpMsg);

            // Send and wait
            //server.send( ByteBuffer.wrap( inMsg.getBytes() ) );

            /*
            Pointer<?>  tmpMessage = Pointer.pointerToString(inMsg, null, null);

            int rc = CoreLibrary.nngSend(server.get(), tmpMessage, inMsg.length(), 0);

            if (rc != 0) {
                String errorMessage = "ERROR: Unable to send a messsage on Push socket";
                System.out.println(errorMessage);

                throw new Exception(errorMessage);
            }
             */

            System.out.println("DEBUG Message sent: " + inMsg);        
        }
    }

    //    public <T2> 
    //    T2 receive(Class<T2> classz) throws Exception {
    //        // Connect, if not connected
    //        if (this.connectedSubFlag == false) {
    //            try {
    //                connectSub();
    //            } catch(Exception e) {
    //                e.printStackTrace();
    //                
    //                throw e;
    //            }
    //        }
    //        
    //        T2 output = null;
    //        
    //        // Will it block the execution?
    //        Message recvMsg = subscriber.receiveMessage();
    //        
    //        ByteBuffer recvBuffer = recvMsg.getBody();
    //        
    //        String result = new String(recvBuffer.array(), "UTF-8");
    //        
    //        System.out.println("DEBUG Response: " + result);
    //        
    //        BaseMessage tmpMsg = new BaseMessage();
    //        
    //        output = tmpMsg.decodeMessage(result, classz);
    //        
    //        if ((output instanceof ServerResponseMessage) == true) {
    //            int statusCode = ((ServerResponseMessage) output).getStatus();
    //            
    //            System.out.println("DEBUG Status Code: " + statusCode);                
    //        }
    //        
    //        return output;
    //    }

    /**
     * Return the received message as a String
     * @return
     * @throws Exception
     */
    public String receive() throws Exception {
        // Connect, if not connected
        if (this.connectedSubFlag == false) {
            try {
                connectSub();

                Thread.sleep(3000);
            } catch(Exception e) {
                e.printStackTrace();

                throw e;
            }
        }

        // Will it block the execution?
        //Message recvMsg = subscriber.receiveMessage();
        
        ByteBuffer  recvMsg = ByteBuffer.allocate(4096);
//        subscriber.receive(recvMsg);

        //ByteBuffer recvBuffer = recvMsg.getBody();

        String result = new String(recvMsg.array(), "UTF-8");

        /*
        Pointer< Pointer< nng_msg > >  tmpMessage = null;

        int rc = CoreLibrary.nngRecvmsg(subscriber.get(), tmpMessage, 0); 

        if (rc != 0) {
            String errorMessage = "ERROR: While receiving message from Sub";
            System.out.println(errorMessage);

            throw new Exception(errorMessage);
        }
        String result = tmpMessage.get().toString();
         */

        System.out.println("DEBUG Response: " + result);

        return result;
    }



    // If an error is generated, pass the server socket to the message directly
    // So, the message will use it directly
    //    public void send(ServerMessage inMessage) throws Exception {
    //        if (server != null) {
    //            if (inMessage != null) {
    //                boolean returnCode;
    //                
    //                // Send message code plus authorizationToken
    //                String msgCode = inMessage.getCodeAndAuthToken();
    //
    //                returnCode = server.sendMore(msgCode);
    //                
    //                if (returnCode == false) {
    //                    String errorMessage = "ERROR: Unable to send multi-part message";
    //
    //                    System.out.println(errorMessage);
    //
    //                    throw new Exception(errorMessage);
    //                }
    //                
    //                // Send message
    //                returnCode = server.send(inMessage.getDataBytes(), 0);
    //                
    //                if (returnCode == false) {
    //                    String errorMessage = "ERROR: Unable to send multi-part message";
    //
    //                    System.out.println(errorMessage);
    //
    //                    throw new Exception(errorMessage);
    //                }
    //            } else {
    //                String errorMessage = "ERROR: Unable to send message. Null input parameter";
    //
    //                System.out.println(errorMessage);
    //
    //                throw new Exception(errorMessage);
    //            }
    //        } else {
    //            String errorMessage = "ERROR: Not connected with server. Unable to send messages";
    //
    //            System.out.println(errorMessage);
    //
    //            throw new Exception(errorMessage);
    //        }
    //    }


    //    public void receive(ServerMessage outMessage) throws Exception {
    //        byte[] tmpMessage = null;
    //
    //        if (server != null) {
    //            if (outMessage != null) {
    //                // Receive message code plus authorization token
    //                tmpMessage = server.recv();
    //                String msgCode = new String(tmpMessage);
    //
    //                outMessage.extractCodeAndAuthToken(msgCode);
    //
    //                // Receive message
    //                tmpMessage = server.recv(0);
    //                outMessage.setDataBytes(tmpMessage);
    //
    //            } else {
    //                String errorMessage = "ERROR: Unable to receive message. Null input parameter";
    //
    //                System.out.println(errorMessage);
    //
    //                throw new Exception(errorMessage);
    //            }
    //        } else {
    //            String errorMessage = "ERROR: Not connected with server. Unable to receive messages";
    //
    //            System.out.println(errorMessage);
    //
    //            throw new Exception(errorMessage);
    //        }
    //    }

    protected NngManager_nng_java1() {   
    }

}


