package com.incomplete.cubegs.common;

import java.io.InputStream;
import java.util.Properties;

import org.eclipse.rap.rwt.SingletonUtil;

import nanomsg.Nanomsg.SocketOption;
import nanomsg.exceptions.IOException;
import nanomsg.pipeline.PushSocket;
import nanomsg.pubsub.SubSocket;
import nanomsg.reqrep.ReqSocket;



public class NngManager_jnano {
    private ReqSocket   server = null;
    private SubSocket    subscriber = null;
    
    private boolean      connectedFlag = false;
    private boolean      connectedSubFlag = false;

    // Only to be executed within the UISession thread
    static public NngManager_jnano getInstance() {
        return SingletonUtil.getSessionInstance(NngManager_jnano.class);
    }
    
    public void connectSub() throws Exception {
        System.out.println("INFO: Creating SUB socket");

        if (this.connectedSubFlag == true) {
            return;
        }

        Properties properties = new Properties();

        // This is required for Tomcat
        InputStream is = this.getClass().getClassLoader().getResourceAsStream("../resources/nng.properties");
        properties.load( is );

        // This is required for Jetty
        //properties.load( new FileInputStream("resources/zeromq.properties") );

        System.out.println("INFO: Properties loaded");


        // Connect with subscriber
        String tmpURL = properties.getProperty("subscriber.address");
        System.out.println("DEBUG: subscriber.address = " + tmpURL);

        if (tmpURL != null && tmpURL.isEmpty() == false) {

            subscriber = new SubSocket();
            // Default timeout
            int timeout = Constants.NNG_DEFAULT_TIMEOUT_MILLISECONDS;

            try {
                timeout = Integer.parseInt(properties.getProperty("subscriber.timeout"));
            } catch (Exception e) {
                // Do nothing
            }
            subscriber.setSocketOpt(SocketOption.NN_SNDTIMEO, timeout );
            subscriber.setSocketOpt(SocketOption.NN_RCVTIMEO, timeout);

            subscriber.connect(tmpURL.trim());
            
            subscriber.subscribe("");

            this.connectedSubFlag = true;
        } else {
            String errorMessage = "ERROR: Unable to create subscriber socket to address: " + tmpURL;
            System.out.println(errorMessage);

            throw new Exception(errorMessage);
        }
    }

    public void connect() throws Exception {
        System.out.println("INFO: Creating sockets");

        if (this.connectedFlag == true) {
            return;
        }

        Properties properties = new Properties();

        // This is required for Tomcat
        InputStream is = this.getClass().getClassLoader().getResourceAsStream("../resources/nng.properties");
        properties.load( is );

        // This is required for Jetty
        //properties.load( new FileInputStream("resources/zeromq.properties") );

        System.out.println("INFO: Properties loaded");


        // Connect with the server
        // Asynchronous calls. User .REQ for synchronous calls
        String tmpURL = properties.getProperty("server.address");
        System.out.println("DEBUG: server.address = " + tmpURL);

        if (tmpURL != null && tmpURL.isEmpty() == false) {
            server = new ReqSocket();

            // Default timeout
            int timeout = Constants.NNG_DEFAULT_TIMEOUT_MILLISECONDS;

            try {
                timeout = Integer.parseInt(properties.getProperty("server.timeout"));
            } catch (Exception e) {
                // Do nothing
            }
            
            server.setSocketOpt(SocketOption.NN_SNDTIMEO, timeout );
            server.setSocketOpt(SocketOption.NN_RCVTIMEO, timeout);

            server.bind(tmpURL.trim());
            
            this.connectedFlag = true;
        } else {
            String errorMessage = "ERROR: Unable to create server socket to address: " + tmpURL;
            System.out.println(errorMessage);

            throw new Exception(errorMessage);
        }
    }

    // TODO. Call this method when the system is shutdown.
    // I do not think at logout time is required
    public void disconnectSub() {
        if (this.connectedSubFlag == true) {
            if (subscriber != null) {
                try {
                    subscriber.close();
                } catch (IOException e) {
                }
                //                CoreLibrary.nngClose(subscriber.get());
            }    

            this.connectedSubFlag = false;
        }
    }

    public void disconnect() {
        if (this.connectedFlag == true) {
            if (server != null) {
                try {
                    server.close();
                } catch (IOException e) {
                }
                //                CoreLibrary.nngClose(server.get());
            }

            this.connectedFlag = false;
        }
    }
    
    public void send(String inMsg) throws Exception {
        // Connect, if not connected
        if (this.connectedFlag == false) {
            try {
                connect();
            } catch(Exception e) {
                e.printStackTrace();

                throw e;
            }
        }

        if (inMsg.isBlank() == false) {            
            // Send and wait
            server.send(inMsg);
            
            /*
            Pointer<?>  tmpMessage = Pointer.pointerToString(inMsg, null, null);

            int rc = CoreLibrary.nngSend(server.get(), tmpMessage, inMsg.length(), 0);

            if (rc != 0) {
                String errorMessage = "ERROR: Unable to send a messsage on Push socket";
                System.out.println(errorMessage);

                throw new Exception(errorMessage);
            }
             */

            System.out.println("DEBUG Message sent: " + inMsg);        
        }
    }
    
    /**
     * Return the received message as a String
     * @return
     * @throws Exception
     */
    public String receive() throws Exception {
        // Connect, if not connected
        if (this.connectedSubFlag == false) {
            try {
                connectSub();

                Thread.sleep(3000);
            } catch(Exception e) {
                e.printStackTrace();

                throw e;
            }
        }

        // Will it block the execution?
        String result = subscriber.recvString(); 
        
//        ByteBuffer  recvMsg = ByteBuffer.allocate(4096);
//        subscriber.receive(recvMsg);

        //Message recvMsg = subscriber.receiveMessage();
        //ByteBuffer recvBuffer = recvMsg.getBody();

//        String result = new String(recvMsg.array(), "UTF-8");

        /*
        Pointer< Pointer< nng_msg > >  tmpMessage = null;

        int rc = CoreLibrary.nngRecvmsg(subscriber.get(), tmpMessage, 0); 

        if (rc != 0) {
            String errorMessage = "ERROR: While receiving message from Sub";
            System.out.println(errorMessage);

            throw new Exception(errorMessage);
        }
        String result = tmpMessage.get().toString();
         */

        System.out.println("DEBUG Response: " + result);

        return result;
    }
    
    protected NngManager_jnano() {   
    }
}
